---
title: Hook Builders
---

# {{ $frontmatter.title }}

Hook builders initialize `useQuery`, `useImmutable`, `useInfinite`, `useMutation`, and `useRevalidate`.

Each builder function accepts an instance of a [fetch client](https://openapi-ts.dev/openapi-fetch/api) and a prefix unique to that client.


::: tip

Prefixes ensure that `swr` will avoid caching requests from different APIs when requests happen to match (e.g. `GET /health` for "API A" and `GET /health` for "API B").

:::

```ts
import createClient from "openapi-fetch";
import { isMatch } from "lodash-es";

import {
  createQueryHook,
  createImmutableHook,
  createInfiniteHook,
  createMutationHook,
  createRevalidateHook,
} from "swr-openapi";

import type { paths } from "./my-openapi-3-schema"; // generated by openapi-typescript

const client = createClient<paths>(/* ... */);
const prefix = "my-api";

export const useQuery = createQueryHook(client, prefix);
export const useImmutable = createImmutableHook(client, prefix);
export const useInfinite = createInfiniteHook(client, prefix);
export const useMutation = createMutationHook(client, prefix);
export const useRevalidate = createRevalidateHook(
  client,
  prefix,
  isMatch, // Or any comparison function
);
```

## API

### Parameters

Each builder hook accepts the same initial parameters:

- `client`: A [fetch client](https://openapi-ts.dev/openapi-fetch/api).
- `prefix`: A prefix unique to the fetch client.

`createRevalidateHook` also accepts a third parameter:

- [`compare`](#compare): A function to compare fetch options).

### Returns

- `createQueryHook` &rarr; [`useQuery`](./use-query.md)
- `createImmutableHook` &rarr; [`useImmutable`](./use-immutable.md)
- `createInfiniteHook` &rarr; [`useInfinite`](./use-infinite.md)
- `createMutationHook` &rarr; [`useMutation`](./use-mutation.md)
- `createRevalidateHook` &rarr; [`useRevalidate`](./use-revalidate.md)

## `compare`

When calling `createRevalidateHook`, a function must be provided with the following contract:

```ts
type Compare = (init: any, partialInit: object) => boolean;
```

This function is used to determine whether or not a cached request should be updated when `revalidate` is called with fetch options.

My personal recommendation is to use lodash's [`isMatch`][lodash-is-match]:

> Performs a partial deep comparison between object and source to determine if object contains equivalent property values.

```ts
const useRevalidate = createRevalidateHook(client, "<unique-key>", isMatch);

const revalidate = useRevalidate();

await revalidate([
  "/path",
  {
    params: {
      query: {
        version: "beta",
      },
    },
  },
]);

// ✅ Would be updated
useQuery("/path", {
  params: {
    query: {
      version: "beta",
    },
  },
});

// ✅ Would be updated
useQuery("/path", {
  params: {
    query: {
      version: "beta",
      other: true,
      example: [1, 2, 3],
    },
  },
});

// ❌ Would not be updated
useQuery("/path", {
  params: {
    query: {},
  },
});

// ❌ Would not be updated
useQuery("/path");

// ❌ Would not be updated
useQuery("/path", {
  params: {
    query: {
      version: "alpha",
    },
  },
});

// ❌ Would not be updated
useQuery("/path", {
  params: {
    query: {
      different: "items",
    },
  },
});
```

[lodash-is-match]: https://lodash.com/docs/4.17.15#isMatch
